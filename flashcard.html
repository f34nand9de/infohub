<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcard Lern-App</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Marked.js f√ºr Markdown-Rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        /* Grundlegende Stildefinitionen */
        :root {
            --bg-color-light: #f8fafc;
            --text-color-light: #334155;
            --card-bg-light: #ffffff;
            --card-border-light: #e2e8f0;
            --primary-light: #8b5cf6; /* Pastell-Lila */
            --primary-dark-light: #7c3aed;
            --secondary-light: #ecfeff; /* Pastell-Blaugr√ºn */
            --correct-light: #4ade80; /* Pastell-Gr√ºn */
            --incorrect-light: #ef4444; /* Pastell-Rot */
            --button-bg-light: #ede9fe;
            --button-text-light: #6d28d9;
            --shadow-light: rgba(0, 0, 0, 0.1);
        }

        /* Dark Mode Variablen */
        html.dark-mode {
            --bg-color-light: #1a202c;
            --text-color-light: #e2e8f0;
            --card-bg-light: #2d3748;
            --card-border-light: #4a5568;
            --primary-light: #a78bfa; /* Pastell-Lila */
            --primary-dark-light: #8b5cf6;
            --secondary-light: #2a4365; /* Pastell-Blaugr√ºn */
            --correct-light: #68d391; /* Pastell-Gr√ºn */
            --incorrect-light: #fc8181; /* Pastell-Rot */
            --button-bg-light: #4c51bf;
            --button-text-light: #e0e7ff;
            --shadow-light: rgba(0, 0, 0, 0.3);
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color-light);
            color: var(--text-color-light);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Start from top */
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            transition: background-color 0.3s ease, color 0.3s ease;
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }

        h1 {
            color: var(--primary-dark-light);
            margin-bottom: 20px;
            text-align: center;
            font-size: 2.5rem;
        }

        .container {
            width: 100%;
            max-width: 900px;
            background-color: var(--card-bg-light);
            border-radius: 15px;
            box-shadow: 0 10px 20px var(--shadow-light);
            padding: 25px;
            margin-bottom: 20px;
            box-sizing: border-box;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }

        /* Dateiupload-Bereich */
        .file-upload-section {
            text-align: center;
            margin-bottom: 20px;
        }

        .file-upload-section input[type="file"] {
            display: none;
        }

        .file-upload-section label {
            background-color: var(--primary-light);
            color: white;
            padding: 12px 25px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.2s ease;
            display: inline-block;
            box-shadow: 0 4px 6px var(--shadow-light);
        }

        .file-upload-section label:hover {
            background-color: var(--primary-dark-light);
            transform: translateY(-2px);
        }

        #file-name-display {
            margin-top: 10px;
            font-style: italic;
            color: var(--text-color-light);
        }

        /* Modusauswahl */
        .mode-selection-header {
            display: flex;
            align-items: center;
            justify-content: center; /* Zentriert den Inhalt */
            gap: 10px; /* Abstand zwischen H2 und Button */
            margin-bottom: 20px;
        }

        .mode-selection-header h2 {
            margin: 0; /* Entfernt Standard-Margin von h2 */
            color: var(--primary-dark-light);
        }

        .info-button {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--primary-light);
            transition: color 0.3s ease;
            padding: 0;
            margin: 0;
        }
        .info-button:hover {
            color: var(--primary-dark-light);
        }


        .mode-selection {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }

        .mode-selection button {
            background-color: var(--button-bg-light);
            color: var(--button-text-light);
            padding: 10px 20px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 2px 4px var(--shadow-light);
        }

        .mode-selection button:hover {
            background-color: var(--primary-light);
            color: white;
            transform: translateY(-2px);
        }

        .mode-selection button.active {
            background-color: var(--primary-dark-light);
            color: white;
        }

        /* Flashcard-Anzeige */
        .flashcard-wrapper {
            perspective: 1000px; /* F√ºr 3D-Flip-Effekt */
            width: 100%;
            max-width: 500px; /* Maximale Breite f√ºr die Karte */
            height: 250px; /* Feste H√∂he f√ºr die Karte */
            margin: 0 auto 30px auto;
            position: relative;
        }

        .flashcard {
            width: 100%;
            height: 100%;
            position: relative; 
            transform-style: preserve-3d;
            cursor: pointer;
            border-radius: 15px;
            box-shadow: 0 8px 16px var(--shadow-light);
            background-color: var(--card-bg-light);
            border: 1px solid var(--card-border-light);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
            word-wrap: break-word;
            overflow: hidden; 
            white-space: normal;
            transition: transform 0.6s; /* Nur der Eltern-Container transformiert */
        }

        .flashcard-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden; /* Die R√ºckseite des Elements ist beim Wegdrehen versteckt */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            font-size: 1.5rem;
            font-weight: 600;
            line-height: 1.4;
            transition: transform 0.6s; /* F√ºge √úbergang hinzu, falls die Gesichter direkt gedreht werden */
        }

        .flashcard-face.front {
            transform: rotateY(0deg); /* Initialzustand */
        }

        .flashcard-face.back {
            transform: rotateY(180deg); /* Initialzustand, umgedreht */
        }

        /* Wenn die Hauptkarte geflippt ist, drehen sich die Faces entsprechend */
        .flashcard.flipped .flashcard-face.front {
            transform: rotateY(180deg);
        }

        .flashcard.flipped .flashcard-face.back {
            transform: rotateY(0deg);
        }
        
        .flashcard-topic {
            font-size: 0.9rem;
            color: #64748b; /* Eine etwas dunklere Farbe f√ºr den Topic-Text */
            margin-bottom: 10px;
        }

        #flashcard-text {
            font-size: 1.5rem;
            font-weight: 600;
        }

        #flashcard-answer {
            font-size: 1.2rem; /* Leicht vergr√∂√üert f√ºr bessere Lesbarkeit */
            font-weight: 400;
        }
        /* Markdown-Inhalt in Flashcards */
        .flashcard-face h1, .flashcard-face h2, .flashcard-face h3 {
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            color: inherit; /* Verhindert, dass Markdown-Headings eine andere Farbe bekommen */
        }
        .flashcard-face p {
            margin-bottom: 0.5em;
        }
        .flashcard-face ul, .flashcard-face ol {
            text-align: left;
            margin-left: 20px;
        }

        /* Quiz-Modus Optionen */
        .quiz-options {
            display: grid;
            grid-template-columns: 1fr 1fr; /* Zwei Spalten */
            gap: 10px;
            margin-top: 20px;
            width: 100%;
            max-width: 500px;
            margin: 20px auto; 
        }

        .quiz-options button {
            background-color: var(--button-bg-light);
            color: var(--button-text-light);
            padding: 12px 15px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 2px 4px var(--shadow-light);
            font-size: 1rem;
            text-align: center;
        }

        .quiz-options button:hover {
            background-color: var(--primary-light);
            color: white;
            transform: translateY(-2px);
        }

        .quiz-options button.correct {
            background-color: var(--correct-light);
            color: white;
        }

        .quiz-options button.incorrect {
            background-color: var(--incorrect-light);
            color: white;
        }

        /* Fortschrittsanzeige */
        .progress-section {
            width: 100%;
            max-width: 600px;
            margin: 20px auto;
            text-align: center;
        }

        .progress-bar-container {
            width: 100%;
            background-color: var(--card-border-light);
            border-radius: 10px;
            height: 20px;
            overflow: hidden;
            margin-top: 10px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            background-color: var(--primary-light); /* Default color, overwritten by gradient */
            border-radius: 10px;
            transition: width 0.5s ease-out, background-image 0.5s ease-out; /* Add transition for background-image */
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: 600;
            font-size: 0.9rem;
        }

        /* Gamification & Buttons */
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .game-controls button {
            background-color: var(--button-bg-light);
            color: var(--button-text-light);
            padding: 12px 25px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 2px 4px var(--shadow-light);
            font-size: 1.1rem;
        }

        .game-controls button:hover {
            background-color: var(--primary-light);
            color: white;
            transform: translateY(-2px);
        }

        .game-controls button.correct-btn {
            background-color: var(--correct-light);
            color: white;
        }

        .game-controls button.correct-btn:hover {
            background-color: #2e8b57; /* Dunkleres Gr√ºn */
        }

        .game-controls button.incorrect-btn {
            background-color: var(--incorrect-light);
            color: white;
        }

        .game-controls button.incorrect-btn:hover {
            background-color: #b91c1c; /* Dunkleres Rot */
        }

        #card-counter {
            text-align: center;
            margin-top: 20px;
            font-size: 1.1rem;
            font-weight: 600;
        }

        /* Motivations-Nachricht */
        .motivation-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--primary-light);
            color: white;
            padding: 20px 30px;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            font-size: 1.8rem;
            font-weight: 700;
            text-align: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            animation: fadeInOut 1s forwards; /* Verk√ºrzt auf 1s */
            white-space: nowrap; /* Verhindert Zeilenumbruch */
        }

        @keyframes fadeInOut {
            0% { opacity: 0; visibility: hidden; transform: translate(-50%, -50%) scale(0.8); }
            10% { opacity: 1; visibility: visible; transform: translate(-50%, -50%) scale(1); }
            90% { opacity: 1; visibility: visible; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; visibility: hidden; transform: translate(-50%, -50%) scale(1.2); }
        }

        /* Dark Mode Toggle */
        .dark-mode-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            font-size: 2rem;
            cursor: pointer;
            color: var(--text-color-light);
            transition: color 0.3s ease;
        }

        .dark-mode-toggle:hover {
            color: var(--primary-dark-light);
        }

        /* Settings Button */
        #settingsBtn {
            position: absolute;
            top: 20px;
            right: 80px; /* Links neben dem Dark Mode Toggle */
            background: none;
            border: none;
            font-size: 2rem;
            cursor: pointer;
            color: var(--text-color-light);
            transition: color 0.3s ease;
        }

        #settingsBtn:hover {
            color: var(--primary-dark-light);
        }


        /* Reset/Review Section */
        .reset-review-section {
            margin-top: 30px;
            text-align: center;
        }

        .reset-review-section button {
            background-color: var(--button-bg-light);
            color: var(--button-text-light);
            padding: 12px 25px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 2px 4px var(--shadow-light);
            font-size: 1.1rem;
            margin: 5px;
        }

        .reset-review-section button:hover {
            background-color: var(--primary-light);
            color: white;
            transform: translateY(-2px);
        }

        /* Responsivit√§t */
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }

            .container {
                padding: 15px;
            }

            .mode-selection {
                flex-direction: column;
                align-items: center;
            }

            .flashcard-wrapper {
                height: 220px; /* Etwas kleiner auf Mobilger√§ten */
            }

            .flashcard-face {
                font-size: 1.3rem;
            }

            .flashcard-face.back {
                font-size: 1rem;
            }

            .quiz-options {
                grid-template-columns: 1fr; /* Eine Spalte im Quiz-Modus */
            }

            .game-controls {
                flex-direction: column;
                align-items: center;
            }

            .dark-mode-toggle {
                top: 10px;
                right: 10px;
                font-size: 1.5rem;
            }
            #settingsBtn {
                top: 10px;
                right: 60px; /* Anpassung f√ºr kleine Bildschirme */
                font-size: 1.5rem;
            }

            .motivation-message {
                font-size: 1.4rem;
                padding: 15px 20px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 1.8rem;
            }

            .flashcard-wrapper {
                height: 200px;
            }

            .flashcard-face {
                font-size: 1.1rem;
            }

            .flashcard-face.back {
                font-size: 0.9rem;
            }
        }

        /* --- Neue Stile f√ºr Maskottchen und Mini-Spiele --- */
        .mascot-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 100px;
            height: 100px;
            z-index: 999;
            /* pointer-events: none; // Jetzt klickbar f√ºr Men√º */
            transition: transform 0.5s ease-out;
            font-size: 4rem; /* Emoji Gr√∂√üe */
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer; /* Zeigt an, dass es klickbar ist */
            background: none; /* Macht den Button unsichtbar */
            border: none;
            padding: 0;
            box-shadow: none;
        }

        .mascot-container.correct-animation {
            animation: mascotCorrect 0.8s ease-out forwards;
        }

        @keyframes mascotCorrect {
            0% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(5deg); }
            100% { transform: translateY(0) rotate(0deg); }
        }

        .mascot-container.incorrect-animation {
            animation: mascotIncorrect 0.8s ease-out forwards;
        }

        @keyframes mascotIncorrect {
            0% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            50% { transform: translateX(10px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }

        /* Abzeichen-Galerie */
        #badgeGallery {
            display: grid; /* Ge√§ndert zu Grid f√ºr die Galerie */
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 15px;
            margin-top: 20px;
            padding: 15px;
        }

        .badge-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            opacity: 0.4; /* Standardm√§√üig ausgegraut */
            transition: opacity 0.3s ease-in-out;
            background-color: var(--button-bg-light); /* Hintergrund f√ºr jedes Abzeichen */
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 2px 5px var(--shadow-light);
        }

        .badge-item.earned {
            opacity: 1; /* Verdient = sichtbar */
            background-color: var(--secondary-light); /* Leichter farbiger Hintergrund, wenn verdient */
        }

        .badge-item .badge-icon {
            font-size: 3rem; /* Emoji Gr√∂√üe f√ºr Abzeichen-Icons */
            margin-bottom: 5px;
            line-height: 1; /* Vertikale Ausrichtung optimieren */
        }

        .badge-item span {
            font-size: 0.9rem; /* Leicht gr√∂√üer */
            font-weight: 600;
            color: var(--text-color-light);
            margin-bottom: 2px;
        }
        .badge-item small {
            font-size: 0.75rem;
            color: #64748b; /* Dunkler als Haupttext */
        }

        /* Overlay f√ºr Mini-Spiele und Einstellungen */
        .overlay-container {
            display: none; /* Standardm√§√üig ausgeblendet */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1001;
            justify-content: center;
            align-items: center;
        }

        .overlay-content {
            background-color: var(--card-bg-light);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5);
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            position: relative; /* F√ºr den Schlie√üen-Button */
        }

        .overlay-content h3 {
            color: var(--primary-dark-light);
            margin-bottom: 20px;
            font-size: 2rem;
        }

        .overlay-controls {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .overlay-controls button {
            background-color: var(--primary-light);
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.3s ease;
        }

        .overlay-controls button:hover {
            background-color: var(--primary-dark-light);
        }

        .close-overlay-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 1.8rem;
            cursor: pointer;
            color: var(--text-color-light);
            transition: color 0.3s ease;
        }
        .close-overlay-btn:hover {
            color: var(--incorrect-light);
        }

        /* Settings specific styles */
        #settingsContent p {
            margin-bottom: 10px;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }
        #settingsContent select {
            padding: 8px;
            border-radius: 8px;
            border: 1px solid var(--card-border-light);
            background-color: var(--button-bg-light);
            color: var(--button-text-light);
            font-size: 1rem;
            margin-left: 10px;
            cursor: pointer;
            transition: border-color 0.2s ease, background-color 0.2s ease;
        }
        #settingsContent select:focus {
            outline: none;
            border-color: var(--primary-dark-light);
        }

        /* Memory Game spezifische Stile */
        #memoryBoard {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* Beispiel: 4 Spalten */
            gap: 10px;
            width: 100%;
            max-width: 500px;
            margin: 20px auto;
        }

        .memory-card {
            width: 100px; 
            height: 100px; 
            background-color: var(--primary-light);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 1.2rem; 
            font-weight: 600;
            color: white;
            transform-style: preserve-3d;
            transition: transform 0.6s ease-out; /* NUR der Eltern-Container transformiert */
            position: relative;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        /* WICHTIG: Gematchte Karten bleiben umgedreht und zeigen den Inhalt */
        .memory-card.flipped, 
        .memory-card.matched { 
            transform: rotateY(180deg);
        }

        .memory-card.matched {
            background-color: var(--correct-light);
            cursor: default;
            opacity: 1; /* Volle Deckkraft f√ºr gematchte Karten */
            pointer-events: none; /* Nicht mehr klickbar, wenn gematcht */
        }

        .memory-card-face { /* Gemeinsame Stile f√ºr Vorder- und R√ºckseite */
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden; /* Versteckt die R√ºckseite, wenn sie weggedreht ist */
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 5px;
            box-sizing: border-box;
            word-wrap: break-word;
        }

        .memory-card-front-face { /* Die Vorderseite der Karte, zeigt das '?' */
            background-color: var(--primary-light);
            color: white;
            font-size: 1.2rem; 
            font-weight: 600;
            transform: rotateY(0deg); /* Initialzustand */
        }

        .memory-card-back-face { /* Die R√ºckseite der Karte, zeigt den Inhalt */
            background-color: var(--card-bg-light);
            color: var(--text-color-light);
            font-size: 1.1rem; 
            /* Wichtig: Initial um 180 Grad gedreht, damit sie nach dem "flip" sichtbar ist */
            transform: rotateY(180deg); 
        }

        @media (max-width: 480px) {
            #memoryBoard {
                grid-template-columns: repeat(3, 1fr); /* 3 Spalten auf kleinen Ger√§ten */
                gap: 8px;
            }
            .memory-card {
                width: 80px;
                height: 80px;
            }
        }

        /* Style for the audio buttons */
        .audio-button {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--primary-dark-light);
            margin-left: 10px;
            padding: 5px;
            border-radius: 50%;
            transition: background-color 0.2s ease;
        }
        .audio-button:hover {
            background-color: rgba(139, 92, 246, 0.2); /* light purple with transparency */
        }
        /* Position audio buttons within flashcard faces */
        .flashcard-face.front .audio-button {
            position: absolute;
            top: 10px;
            right: 10px;
        }
        .flashcard-face.back .audio-button {
            position: absolute;
            top: 10px;
            right: 10px;
        }

        /* Maskottchen Anpassungs-Overlay */
        #mascotCustomizationOverlay .mascot-options {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }

        #mascotCustomizationOverlay .mascot-option-item {
            width: 80px; /* Quadratische Box */
            height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border: 2px solid var(--card-border-light);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 2.5rem;
            background-color: var(--button-bg-light);
            color: var(--button-text-light);
        }

        #mascotCustomizationOverlay .mascot-option-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px var(--shadow-light);
            border-color: var(--primary-light);
        }

        #mascotCustomizationOverlay .mascot-option-item.selected {
            border-color: var(--primary-dark-light);
            box-shadow: 0 0 0 3px var(--primary-dark-light);
            background-color: var(--primary-light);
            color: white;
        }
        #mascotCustomizationOverlay .mascot-option-item.locked {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }
        #mascotCustomizationOverlay .mascot-option-item.locked:hover {
            transform: none;
            box-shadow: none;
            border-color: var(--card-border-light);
        }
        #mascotCustomizationOverlay .mascot-option-item small {
            font-size: 0.7rem;
            text-align: center;
            line-height: 1.2;
        }

        /* Styles f√ºr den Sprecher-Button im Info-Overlay */
        #speakSelectedTextBtn {
            position: fixed; /* Changed from absolute to fixed */
            background-color: var(--primary-light);
            color: white;
            border: none;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            font-size: 1.2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1002; /* √úber allem anderen */
            display: none; /* Standardm√§√üig versteckt */
            transition: background-color 0.2s ease;
        }

        #speakSelectedTextBtn:hover {
            background-color: var(--primary-dark-light);
        }

    </style>
</head>
<body>
    <button id="darkModeToggle" class="dark-mode-toggle">üí°</button>
    <button id="settingsBtn" class="settings-button">‚öôÔ∏è</button>

    <h1>Flashcard Lern-App</h1>

    <div class="container">
        <div class="file-upload-section">
            <h2>1. Lerninhalte hochladen</h2>
            <input type="file" id="fileInput" accept=".txt">
            <label for="fileInput">Datei ausw√§hlen</label>
            <div id="file-name-display">Noch keine Datei ausgew√§hlt.</div>
            <small>Format: Info-Text (bis !flashcards)<br>!flashcards<br>Frage : Antwort (jede Zeile eine Karte)</small><br>
            <small>Optional: Thema|Frage : Antwort</small>

            <h3 style="margin-top: 20px;">Gespeicherte Lerninhalte laden</h3>
            <select id="savedSetsSelect" style="width: 80%; padding: 10px; border-radius: 8px; border: 1px solid var(--card-border-light); background-color: var(--button-bg-light); color: var(--button-text-light); font-size: 1rem; text-align: center;">
                <option value="">--- Gespeicherte Inhalte ausw√§hlen ---</option>
            </select>
        </div>
    </div>

    <div class="container" id="app-controls" style="display: none;">
        <div class="mode-selection-header">
            <h2>2. Lernmodus w√§hlen</h2>
            <button id="showInfoBtn" class="info-button" title="Lerneinheit anzeigen">‚ÑπÔ∏è</button>
        </div>
        <div class="mode-selection">
            <button id="normalModeBtn" class="active">Normalmodus</button>
            <button id="quizModeBtn">Quizmodus</button>
        </div>

        <!-- Neue Sektion f√ºr Aktionsbuttons (Abzeichen, Mini-Spiel) -->
        <div class="action-buttons">
            <button id="showBadgesBtn">üèÜ Abzeichen</button>
            <button id="startGameBtn">üéÆ Mini-Spiel starten</button>
        </div>
        
        <div class="progress-section">
            <h3>Fortschritt: <span id="progress-text">0%</span></h3>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <p id="card-counter">Bearbeitete Karten: 0 | Richtig: 0 | Falsch: 0</p>
        </div>

        <div class="flashcard-wrapper">
            <div class="flashcard" id="flashcard">
                <div class="flashcard-face front">
                    <span id="flashcard-topic-front" class="flashcard-topic"></span>
                    <span id="flashcard-text">Lade eine Datei hoch, um zu beginnen!</span>
                    <button class="audio-button" id="playQuestionAudio">üîä</button>
                </div>
                <div class="flashcard-face back">
                    <span id="flashcard-topic-back" class="flashcard-topic"></span>
                    <span id="flashcard-answer">Antwort</span>
                    <button class="audio-button" id="playAnswerAudio">üîä</button>
                </div>
            </div>
        </div>

        <div class="quiz-options" id="quizOptions" style="display: none;">
            <!-- Quiz-Antwortoptionen werden hier eingef√ºgt -->
        </div>

        <div class="game-controls">
            <button id="correctBtn" class="correct-btn">‚úÖ Richtig gewusst</button>
            <button id="incorrectBtn" class="incorrect-btn">‚ùå Falsch</button>
            <button id="nextCardBtn">N√§chste Karte</button>
            <button id="prevCardBtn">Vorherige Karte</button>
        </div>

        <div class="reset-review-section">
            <button id="reviewIncorrectBtn" style="display: none;">Falsch beantwortete Karten wiederholen</button>
            <button id="resetProgressBtn">Fortschritt zur√ºcksetzen</button>
        </div>
    </div>

    <div id="motivationMessage" class="motivation-message"></div>

    <!-- Maskottchen Container (jetzt klickbar) -->
    <button class="mascot-container" id="mascotContainer">
        <span id="mascotEmoji"></span>
    </button>

    <!-- Abzeichen-Galerie Overlay -->
    <div class="overlay-container" id="badgeGalleryOverlay">
        <div class="overlay-content">
            <button class="close-overlay-btn" id="closeBadgesBtn">‚úñ</button>
            <h3>Deine Abzeichen</h3>
            <div id="badgeGallery">
                <!-- Abzeichen werden hier dynamisch eingef√ºgt -->
            </div>
        </div>
    </div>

    <!-- Mini-Spiel Overlay -->
    <div class="overlay-container" id="miniGameOverlay">
        <div class="overlay-content">
            <button class="close-overlay-btn" id="closeGameBtn">‚úñ</button>
            <h3 id="gameTitle">Mini-Spiel</h3>
            <div id="gameArea">
                <!-- Spielinhalte werden hier dynamisch geladen -->
            </div>
            <div class="overlay-controls">
                <button id="nextGameBtn" style="display: none;">N√§chstes Spiel</button>
            </div>
        </div>
    </div>

    <!-- NEU: Einstellungen Overlay -->
    <div class="overlay-container" id="settingsOverlay">
        <div class="overlay-content" id="settingsContent">
            <button class="close-overlay-btn" id="closeSettingsBtn">‚úñ</button>
            <h3>Einstellungen</h3>
            <p>Sprache f√ºr Frage: 
                <select id="questionLangSelect">
                    <!-- Optionen werden dynamisch per JavaScript eingef√ºgt -->
                </select>
            </p>
            <p>Sprache f√ºr Antwort:
                <select id="answerLangSelect">
                    <!-- Optionen werden dynamisch per JavaScript eingefu√üt -->
                </select>
            </p>
            <p style="font-size: 0.8rem; color: #666;">
                Verf√ºgbare Sprachen h√§ngen von Ihrem Browser und Betriebssystem ab.
            </p>
        </div>
    </div>

    <!-- NEU: Maskottchen-Anpassungs-Overlay -->
    <div class="overlay-container" id="mascotCustomizationOverlay">
        <div class="overlay-content">
            <button class="close-overlay-btn" id="closeMascotCustomizationBtn">‚úñ</button>
            <h3>Maskottchen anpassen</h3>
            <div class="mascot-options">
                <!-- Maskottchen-Optionen werden hier dynamisch eingef√ºgt -->
            </div>
        </div>
    </div>

    <!-- NEU: Info Overlay f√ºr die Lerneinheit -->
    <div class="overlay-container" id="infoOverlay">
        <div class="overlay-content">
            <button class="close-overlay-btn" id="closeInfoBtn">‚úñ</button>
            <h3>Lerneinheit: √úberblick</h3>
            <div id="infoContent" style="text-align: left; max-width: 600px; margin: 0 auto; padding: 10px;">
                <!-- Inhalt der TXT-Datei wird hier als Markdown gerendert -->
            </div>
        </div>
    </div>
    <!-- NEU: Sprecher-Button f√ºr ausgew√§hlten Text im Info-Overlay -->
    <button id="speakSelectedTextBtn">üîä</button>


    <script>
        // DOM-Elemente abrufen
        const fileInput = document.getElementById('fileInput');
        const fileNameDisplay = document.getElementById('file-name-display');
        const appControls = document.getElementById('app-controls');
        const flashcard = document.getElementById('flashcard');
        const flashcardText = document.getElementById('flashcard-text');
        const flashcardAnswer = document.getElementById('flashcard-answer');
        const flashcardTopicFront = document.getElementById('flashcard-topic-front');
        const flashcardTopicBack = document.getElementById('flashcard-topic-back');
        const correctBtn = document.getElementById('correctBtn');
        const incorrectBtn = document.getElementById('incorrectBtn');
        const nextCardBtn = document.getElementById('nextCardBtn');
        const prevCardBtn = document.getElementById('prevCardBtn');
        const cardCounterDisplay = document.getElementById('card-counter');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progress-text');
        const motivationMessage = document.getElementById('motivationMessage');
        const normalModeBtn = document.getElementById('normalModeBtn');
        const quizModeBtn = document.getElementById('quizModeBtn');
        const quizOptionsContainer = document.getElementById('quizOptions');
        const darkModeToggle = document.getElementById('darkModeToggle');
        const resetProgressBtn = document.getElementById('resetProgressBtn');
        const reviewIncorrectBtn = document.getElementById('reviewIncorrectBtn');
        const savedSetsSelect = document.getElementById('savedSetsSelect');

        // Audio-Elemente
        const playQuestionAudioBtn = document.getElementById('playQuestionAudio');
        const playAnswerAudioBtn = document.getElementById('playAnswerAudio');
        const questionLangSelect = document.getElementById('questionLangSelect');
        const answerLangSelect = document.getElementById('answerLangSelect');

        // Gamification Elemente
        const mascotContainer = document.getElementById('mascotContainer');
        const mascotEmoji = document.getElementById('mascotEmoji');
        const showBadgesBtn = document.getElementById('showBadgesBtn');
        const badgeGalleryOverlay = document.getElementById('badgeGalleryOverlay');
        const badgeGallery = document.getElementById('badgeGallery');
        const closeBadgesBtn = document.getElementById('closeBadgesBtn');
        const startGameBtn = document.getElementById('startGameBtn');
        const miniGameOverlay = document.getElementById('miniGameOverlay');
        const closeGameBtn = document.getElementById('closeGameBtn');
        const gameTitle = document.getElementById('gameTitle');
        const gameArea = document.getElementById('gameArea');
        const nextGameBtn = document.getElementById('nextGameBtn');

        // Settings Elemente
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsOverlay = document.getElementById('settingsOverlay');
        const closeSettingsBtn = document.getElementById('closeSettingsBtn');

        // Maskottchen Anpassungs-Elemente
        const mascotCustomizationOverlay = document.getElementById('mascotCustomizationOverlay');
        const closeMascotCustomizationBtn = document.getElementById('closeMascotCustomizationBtn');
        const mascotOptionsContainer = mascotCustomizationOverlay.querySelector('.mascot-options');

        // NEU: Info Overlay Elemente
        const showInfoBtn = document.getElementById('showInfoBtn');
        const infoOverlay = document.getElementById('infoOverlay');
        const closeInfoBtn = document.getElementById('closeInfoBtn');
        const infoContent = document.getElementById('infoContent');
        const speakSelectedTextBtn = document.getElementById('speakSelectedTextBtn');


        // Globale Variablen
        let flashcards = []; 
        let allFlashcardSets = {}; 
        let currentActiveSetKey = null; 
        let originalFlashcards = []; 
        let currentCardIndex = 0; 
        let isReviewMode = false; 
        let learningMode = 'normal'; // 'normal', 'quiz', 'game'
        let darkModeEnabled = true; 
        // F√ºr Abzeichen-Stufen: Speichere den h√∂chsten erreichten Level f√ºr jedes Abzeichen
        // z.B. { 'total_correct': 2, 'quiz_master': 1 }
        let earnedBadges = {}; 
        let gameMode = ''; 
        let currentGameCardSet = []; 
        let memoryCards = []; 
        let flippedMemoryCards = []; 
        let matchedMemoryPairs = 0; 
        let isMemoryChecking = false; 
        let availableVoices = []; 
        let loadedQuestionLang = 'de-DE'; 
        let loadedAnswerLang = 'de-DE';
        let userSelectedMascotEmoji = 'üôÇ'; // Dies ist das vom Benutzer ausgew√§hlte Maskottchen-Emoji


        // Maskottchen Emojis
        const MASCOT_HAPPY = 'üòä';
        const MASCOT_NEUTRAL = 'üôÇ';
        const MASCOT_THINKING = 'ü§î';

        // NEU: Verf√ºgbare Maskottchen-Optionen
        const MASCOT_EMOJIS = [
            { emoji: 'üôÇ', name: 'Standard', unlockCriteria: { type: 'always' } },
            { emoji: 'üòé', name: 'Cooler Typ', unlockCriteria: { type: 'total_correct', threshold: 10 } },
            { emoji: 'ü§©', name: 'Begeistert', unlockCriteria: { type: 'quiz_master', threshold: 1 } },
            { emoji: 'üöÄ', name: 'Rakete', unlockCriteria: { type: 'first_set', threshold: 1 } },
            { emoji: 'üéì', name: 'Absolvent', unlockCriteria: { type: 'total_correct', threshold: 50 } },
            { emoji: 'üí°', name: 'Denker', unlockCriteria: { type: 'memory_pro', threshold: 1 } },
            { emoji: 'ü•≥', name: 'Party', unlockCriteria: { type: 'total_correct', threshold: 100 } }
        ];


        // Abzeichen Definitionen mit Levels und Schwellenwerten
        const BADGES = [
            { id: 'first_card', name: 'Erste Schritte!', 
              levels: [{ level: 1, description: 'Die allererste Karte gelernt!', icon: '‚ú®', threshold: 1 }]
            },
            { id: 'total_correct', name: 'Richtige Antworten', 
              levels: [
                { level: 1, description: '10 Karten richtig beantwortet!', icon: 'üî•', threshold: 10 },
                { level: 2, description: '50 Karten richtig gemeistert!', icon: 'üåü', threshold: 50 },
                { level: 3, description: '100 Karten richtig gewusst!', icon: 'üëë', threshold: 100 }
              ]
            },
            { id: 'first_set', name: 'Satz-Bezwinger!', 
              levels: [{ level: 1, description: 'Den ersten Kartensatz komplett gelernt!', icon: '‚úÖ', threshold: 1 }]
            },
            { id: 'quiz_master', name: 'Quiz-K√∂nig/in!', 
              levels: [{ level: 1, description: '10 Quizfragen korrekt gel√∂st!', icon: 'üß†', threshold: 10 }]
            },
            { id: 'review_hero', name: 'Wiederholungs-Ass!', 
              levels: [{ level: 1, description: 'Alle Fehlerkarten einmal wiederholt!', icon: 'üîÑ', threshold: 1 }]
            },
            { id: 'memory_pro', name: 'Memory-Meister!', 
              levels: [{ level: 1, description: 'Ein Memory-Spiel fehlerfrei beendet!', icon: 'üí°', threshold: 1 }]
            }
        ];

        // Hilfsfunktion zur Formatierung eines Datums f√ºr dueDate
        function getTodayIsoDate() {
            return new Date().toISOString().split('T')[0];
        }

        // Initialisierung beim Laden der Seite
        document.addEventListener('DOMContentLoaded', initApp);

        function initApp() {
            loadStateFromLocalStorage(); 
            updateDarkModeUI(); 
            populateSavedSetsSelect(); 
            setMascotDisplay(userSelectedMascotEmoji); // Initialisiert das Maskottchen-Emoji auf den zuletzt ausgew√§hlten Emoji

            // F√ºge Event Listener f√ºr 'animationend' hinzu
            mascotContainer.addEventListener('animationend', () => {
                mascotContainer.classList.remove('correct-animation', 'incorrect-animation');
                setMascotDisplay(userSelectedMascotEmoji); // Kehre zum benutzerdefinierten Maskottchen zur√ºck
            });


            // F√ºlle die flashcards basierend auf dem geladenen Zustand und Modus
            if (currentActiveSetKey && allFlashcardSets[currentActiveSetKey]) {
                originalFlashcards = allFlashcardSets[currentActiveSetKey].cards; // Lade Karten aus dem Set-Objekt
            } else {
                originalFlashcards = []; 
                appControls.style.display = 'none'; 
            }


            if (isReviewMode) {
                flashcards = originalFlashcards.filter(card => card.progress.normal === 'incorrect');
                if (flashcards.length === 0) {
                    isReviewMode = false; 
                    flashcards = [...originalFlashcards]; 
                    shuffleFlashcards();
                    currentCardIndex = 0;
                    showMotivationalMessage('Wiederholungsmodus beendet, keine falschen Karten mehr!');
                } else {
                    shuffleFlashcards();
                    normalModeBtn.textContent = 'Lernmodus verlassen';
                    quizModeBtn.style.display = 'none';
                    showBadgesBtn.style.display = 'none';
                    startGameBtn.style.display = 'none';
                }
            } else {
                flashcards = [...originalFlashcards]; 
                shuffleFlashcards();
                // Beim Start im Normalmodus, sortiere Karten nach SRS DueDate
                if (learningMode === 'normal' && flashcards.length > 0) {
                    // Filtert Karten, die heute oder fr√ºher f√§llig sind, und mischt sie
                    const dueCards = flashcards.filter(card => new Date(card.srs.dueDate) <= new Date(getTodayIsoDate()));
                    shuffleArray(dueCards); // Mischen der f√§lligen Karten
                    
                    // Filtert Karten, die noch nicht f√§llig sind
                    const notDueCards = flashcards.filter(card => new Date(card.srs.dueDate) > new Date(getTodayIsoDate()));
                    shuffleArray(notDueCards); // Mischen der nicht f√§lligen Karten
                    
                    // Setze flashcards neu zusammen: zuerst f√§llige, dann nicht f√§llige
                    flashcards = [...dueCards, ...notDueCards];
                    currentCardIndex = 0; // Beginne immer mit der ersten Karte
                }
            }
            
            updateProgress();
            updateCardCounter();

            if (originalFlashcards.length > 0) {
                appControls.style.display = 'block';
                displayCard();
            } else {
                appControls.style.display = 'none';
            }
            
            // Event-Listener f√ºr Sprachauswahl√§nderungen hinzuf√ºgen, um Zustand zu speichern
            questionLangSelect.addEventListener('change', saveStateToLocalStorage);
            answerLangSelect.addEventListener('change', saveStateToLocalStorage);

            // Stimmenliste beim Start und bei √Ñnderungen laden
            if ('speechSynthesis' in window) {
                window.speechSynthesis.onvoiceschanged = populateVoiceList;
                setTimeout(populateVoiceList, 100); 
            } else {
                questionLangSelect.innerHTML = '<option value="">Nicht unterst√ºtzt</option>';
                answerLangSelect.innerHTML = '<option value="">Nicht unterst√ºtzt</option>';
                questionLangSelect.disabled = true;
                answerLangSelect.disabled = true;
                playQuestionAudioBtn.disabled = true;
                playAnswerAudioBtn.disabled = true;
                showMotivationalMessage('Audio-Wiedergabe nicht verf√ºgbar. Browser unterst√ºtzt keine Text-zu-Sprache.');
            }

            // F√ºge Event-Listener f√ºr Textauswahl im Info-Overlay hinzu
            infoContent.addEventListener('mouseup', handleInfoTextSelection);
            // Klick au√üerhalb des Buttons, um ihn zu verstecken
            document.addEventListener('mousedown', (event) => {
                if (speakSelectedTextBtn.style.display === 'block' && !speakSelectedTextBtn.contains(event.target)) {
                    speakSelectedTextBtn.style.display = 'none';
                }
            });
            // Klick auf den Button zum Vorlesen
            speakSelectedTextBtn.addEventListener('click', () => {
                const selectedText = window.getSelection().toString().trim();
                if (selectedText) {
                    const selectedLang = questionLangSelect.value || navigator.language || 'de-DE';
                    speakText(selectedText, selectedLang);
                }
                speakSelectedTextBtn.style.display = 'none'; // Button nach dem Klicken verstecken
            });
        }

        // --- Event-Handler f√ºr Textauswahl im Info-Overlay ---
        function handleInfoTextSelection(event) {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();

            // √úberpr√ºfe, ob Text ausgew√§hlt wurde, ob das Info-Overlay sichtbar ist UND ob die Auswahl innerhalb von infoContent ist
            if (selectedText.length > 0 && infoOverlay.style.display === 'flex' && infoContent.contains(selection.anchorNode)) {
                const range = selection.getRangeAt(0);
                const rect = range.getBoundingClientRect(); // Bounding Rect relativ zum Viewport

                // Positioniere den speakSelectedTextBtn relativ zum Viewport (fixed position)
                speakSelectedTextBtn.style.left = `${rect.right + 10}px`; // 10px rechts von der Auswahl
                speakSelectedTextBtn.style.top = `${rect.top}px`; // Oberkante der Auswahl
                speakSelectedTextBtn.style.display = 'flex';
            } else {
                speakSelectedTextBtn.style.display = 'none';
            }
        }


        // --- Dateiupload und Parsen ---
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const fileName = file.name;
                fileNameDisplay.textContent = `Ausgew√§hlte Datei: ${fileName}`;
                const reader = new FileReader();
                reader.onload = (e) => {
                    parseFile(e.target.result, fileName); 
                    event.target.value = ''; 
                };
                reader.readAsText(file);
            } else {
                fileNameDisplay.textContent = 'Noch keine Datei ausgew√§hlt.';
            }
        });

        function parseFile(text, fileName) {
            let rawInfoContent = '';
            let flashcardContent = text;
            const delimiter = '!flashcards';

            // Split the file content by the delimiter
            const parts = text.split(delimiter);
            if (parts.length > 1) {
                rawInfoContent = parts[0].trim();
                flashcardContent = parts[1].trim();
            } else {
                // If delimiter is not found, the entire file is considered flashcard content
                // and there is no specific info section from the file itself.
                rawInfoContent = ''; // No explicit info section
                flashcardContent = text;
            }

            const lines = flashcardContent.split('\n').filter(line => line.trim() !== '');
            const parsedCards = lines.map(line => {
                let topic = null;
                let question;
                let answer;

                // √úberpr√ºfe zuerst auf das Thema|Frage : Antwort Format
                if (line.includes('|') && line.includes(':')) {
                    const parts = line.split('|');
                    topic = parts[0].trim();
                    const qa = parts.slice(1).join('|').split(':');
                    question = qa[0].trim();
                    answer = qa.slice(1).join(':').trim();
                } 
                // Dann auf das Frage : Antwort Format
                else if (line.includes(':')) {
                    const parts = line.split(':');
                    question = parts[0].trim();
                    answer = parts.length > 1 ? parts.slice(1).join(':').trim() : '';
                } 
                // Wenn kein : vorhanden ist, wird diese Zeile nicht als Karte behandelt
                else {
                    return null; // Diese Zeile ist keine Flashcard
                }
                return { 
                    question, 
                    answer, 
                    topic, 
                    progress: {
                        normal: 'unanswered',
                        quiz: 'unanswered'
                    },
                    srs: { // NEU: SRS-Eigenschaften
                        interval: 0, // In Tagen
                        easeFactor: 2.5, // Anf√§nglicher Ease Factor
                        repetitions: 0, // Anzahl aufeinanderfolgender richtiger Antworten
                        dueDate: getTodayIsoDate() // Wann die Karte das n√§chste Mal f√§llig ist
                    }
                };
            }).filter(card => card !== null); // Entferne alle null-Werte

            allFlashcardSets[fileName] = {
                cards: parsedCards,
                rawInfoContent: rawInfoContent // Speichere den extrahierten Info-Inhalt
            };
            currentActiveSetKey = fileName;
            originalFlashcards = parsedCards;

            flashcards = [...originalFlashcards];
            shuffleFlashcards();
            currentCardIndex = 0;
            isReviewMode = false;
            appControls.style.display = 'block';
            displayCard();
            updateProgress();
            updateCardCounter();
            saveStateToLocalStorage();
            populateSavedSetsSelect(); 
            savedSetsSelect.value = fileName; 
        }

        function shuffleFlashcards() {
            for (let i = flashcards.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [flashcards[i], flashcards[j]] = [flashcards[j], flashcards[i]];
            }
        }

        // --- Kartendarstellung und Logik ---
        flashcard.addEventListener('click', () => {
            if (learningMode === 'normal') {
                flashcard.classList.toggle('flipped');
            }
        });

        function displayCard() {
            if (flashcards.length === 0) {
                flashcardText.innerHTML = 'Keine Karten verf√ºgbar. Lade eine Datei hoch oder beende den Wiederholungsmodus!';
                flashcardAnswer.innerHTML = '';
                flashcardTopicFront.textContent = '';
                flashcardTopicBack.textContent = '';
                flashcard.classList.remove('flipped');
                quizOptionsContainer.style.display = 'none';
                correctBtn.style.display = 'none';
                incorrectBtn.style.display = 'none';
                nextCardBtn.style.display = 'none';
                prevCardBtn.style.display = 'none';
                playQuestionAudioBtn.style.display = 'none';
                playAnswerAudioBtn.style.display = 'none';
                reviewIncorrectBtn.style.display = (getIncorrectlyAnsweredCount(learningMode) > 0 && !isReviewMode) ? 'block' : 'none';
                return;
            }

            if (currentCardIndex >= flashcards.length) {
                if (isReviewMode) {
                    showMotivationalMessage('Alle falsch beantworteten Karten wiederholt!');
                    setLearningMode('normal'); 
                    earnBadge('review_hero');
                } else {
                    flashcardText.innerHTML = 'Alle Karten bearbeitet!';
                    flashcardAnswer.innerHTML = 'Gut gemacht!';
                    flashcardTopicFront.textContent = '';
                    flashcardTopicBack.textContent = '';
                    flashcard.classList.remove('flipped');
                    quizOptionsContainer.style.display = 'none';
                    correctBtn.style.display = 'none';
                    incorrectBtn.style.display = 'none';
                    nextCardBtn.style.display = 'none';
                    prevCardBtn.style.display = 'none';
                    playQuestionAudioBtn.style.display = 'none'; 
                    playAnswerAudioBtn.style.display = 'none';
                    reviewIncorrectBtn.style.display = (getIncorrectlyAnsweredCount(learningMode) > 0) ? 'block' : 'none';
                    if (originalFlashcards.length > 0 && 
                        originalFlashcards.every(card => card.progress[learningMode] !== 'unanswered')) { 
                        earnBadge('first_set'); 
                    }
                }
                return;
            }

            correctBtn.style.display = 'inline-block';
            incorrectBtn.style.display = 'inline-block';
            nextCardBtn.style.display = 'inline-block';
            // Prev-Button im SRS-Modus verstecken, da die Reihenfolge nicht linear ist
            prevCardBtn.style.display = (learningMode === 'normal' && !isReviewMode) ? 'inline-block' : 'none'; 

            playQuestionAudioBtn.style.display = 'block'; 
            playAnswerAudioBtn.style.display = 'block';
            reviewIncorrectBtn.style.display = 'none'; 

            const currentCard = flashcards[currentCardIndex];
            flashcardText.innerHTML = marked.parse(currentCard.question);
            flashcardAnswer.innerHTML = marked.parse(currentCard.answer);
            flashcardTopicFront.textContent = currentCard.topic ? `Thema: ${currentCard.topic}` : '';
            flashcardTopicBack.textContent = currentCard.topic ? `Thema: ${currentCard.topic}` : '';
            flashcard.classList.remove('flipped'); 

            if (learningMode === 'quiz') {
                quizOptionsContainer.style.display = 'grid';
                displayQuizOptions(currentCard);
            } else {
                quizOptionsContainer.style.display = 'none';
            }
        }

        // --- Audio-Feedback Funktionen ---
        function populateVoiceList() {
            availableVoices = window.speechSynthesis.getVoices();
            const langSelectors = [questionLangSelect, answerLangSelect];
            
            const targetQuestionLang = loadedQuestionLang; 
            const targetAnswerLang = loadedAnswerLang;

            langSelectors.forEach(selectElement => {
                selectElement.innerHTML = ''; 

                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = 'Auto (System-Standard)';
                selectElement.appendChild(defaultOption);

                const addedLanguages = new Set(); 

                availableVoices.forEach(voice => {
                    if (!addedLanguages.has(voice.lang)) {
                        const option = document.createElement('option');
                        option.value = voice.lang;
                        option.textContent = `${voice.name} (${voice.lang})${voice.default ? ' (Standard)' : ''}`;
                        selectElement.appendChild(option);
                        addedLanguages.add(voice.lang);
                    }
                });

                let selectedValue = (selectElement === questionLangSelect) ? targetQuestionLang : targetAnswerLang;
                
                if (availableVoices.some(v => v.lang === selectedValue)) {
                    selectElement.value = selectedValue;
                } else if (availableVoices.some(v => v.lang === navigator.language)) { 
                    selectElement.value = navigator.language;
                } else if (availableVoices.some(v => v.default)) { 
                    selectElement.value = availableVoices.find(v => v.default).lang;
                } else if (availableVoices.length > 0) { 
                    selectElement.value = availableVoices[0].lang;
                } else {
                    selectElement.value = ''; 
                }
            });

            if (availableVoices.length === 0) {
                questionLangSelect.innerHTML = '<option value="">Keine Stimmen verf√ºgbar</option>';
                answerLangSelect.innerHTML = '<option value="">Keine Stimmen verf√ºgbar</option>';
                questionLangSelect.disabled = true;
                answerLangSelect.disabled = true;
                playQuestionAudioBtn.disabled = true;
                playAnswerAudioBtn.disabled = true;
            } else {
                questionLangSelect.disabled = false;
                answerLangSelect.disabled = false;
                playQuestionAudioBtn.disabled = false;
                playAnswerAudioBtn.disabled = false;
            }
        }


        playQuestionAudioBtn.addEventListener('click', (event) => {
            event.stopPropagation(); 
            if (flashcards.length > 0) {
                const currentCard = flashcards[currentCardIndex];
                const selectedLang = questionLangSelect.value || navigator.language || 'de-DE'; 
                speakText(currentCard.question, selectedLang);
            }
        });

        playAnswerAudioBtn.addEventListener('click', (event) => {
            event.stopPropagation(); 
            if (flashcards.length > 0) {
                const currentCard = flashcards[currentCardIndex];
                const selectedLang = answerLangSelect.value || navigator.language || 'de-DE'; 
                speakText(currentCard.answer, selectedLang);
            }
        });

        function speakText(text, lang = 'de-DE') {
            if (!('speechSynthesis' in window) || window.speechSynthesis.getVoices().length === 0) {
                console.warn("Text-to-Speech wird von diesem Browser nicht unterst√ºtzt oder Stimmen sind noch nicht geladen.");
                showMotivationalMessage('Audio-Wiedergabe nicht verf√ºgbar.');
                return;
            }
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = lang; 

            const voiceToUse = availableVoices.find(voice => voice.lang === lang);
            if (voiceToUse) {
                utterance.voice = voiceToUse;
            } else {
                const baseLang = lang.split('-')[0];
                const fallbackVoice = availableVoices.find(voice => voice.lang.startsWith(baseLang));
                if (fallbackVoice) {
                    utterance.voice = fallbackVoice;
                } else {
                    console.warn(`Keine spezifische Stimme f√ºr "${lang}" gefunden, verwende Browser-Standard.`);
                }
            }

            window.speechSynthesis.cancel(); 
            window.speechSynthesis.speak(utterance);
        }

        // --- Hilfsfunktionen zur Fortschrittsberechnung ---
        function getCorrectlyAnsweredCount(mode) {
            return originalFlashcards.filter(card => card.progress[mode] === 'correct').length;
        }

        function getIncorrectlyAnsweredCount(mode) {
            return originalFlashcards.filter(card => card.progress[mode] === 'incorrect').length;
        }

        function getProcessedCardsCount(mode) {
            return originalFlashcards.filter(card => card.progress[mode] === 'correct' || card.progress[mode] === 'incorrect').length;
        }

        // --- Quiz-Modus Optionen ---
        function displayQuizOptions(currentCard) {
            quizOptionsContainer.innerHTML = '';
            quizOptionsContainer.style.display = 'grid';

            const options = [];
            options.push(currentCard.answer);

            let incorrectOptions = [];
            const allOtherAnswers = originalFlashcards
                .map(card => card.answer)
                .filter(answer => answer !== currentCard.answer && answer.trim() !== ''); 
            
            shuffleArray(allOtherAnswers);

            for (let i = 0; i < allOtherAnswers.length && incorrectOptions.length < 3; i++) {
                if (!incorrectOptions.includes(allOtherAnswers[i])) {
                    incorrectOptions.push(allOtherAnswers[i]);
                }
            }
            
            let placeholderCounter = 1;
            while (incorrectOptions.length < 3) {
                let placeholder = `Platzhalter-Antwort ${placeholderCounter}`;
                if (!options.includes(placeholder) && !incorrectOptions.includes(placeholder) && placeholder !== currentCard.answer) {
                    incorrectOptions.push(placeholder);
                    placeholderCounter++;
                } else {
                    placeholderCounter++;
                }
            }

            options.push(...incorrectOptions);
            shuffleArray(options);

            options.forEach(option => {
                const button = document.createElement('button');
                button.textContent = option; 
                button.addEventListener('click', () => handleQuizAnswer(button, option === currentCard.answer));
                quizOptionsContainer.appendChild(button);
            });
        }

        function handleQuizAnswer(clickedButton, isCorrect) {
            Array.from(quizOptionsContainer.children).forEach(button => {
                button.disabled = true;
                if (button.textContent === flashcards[currentCardIndex].answer) {
                    button.classList.add('correct');
                }
                if (button === clickedButton && !isCorrect) {
                    button.classList.add('incorrect');
                }
            });

            setTimeout(() => {
                if (isCorrect) {
                    handleAnswer(true); // Rufe handleAnswer mit korrektem Wert auf
                } else {
                    handleAnswer(false); // Rufe handleAnswer mit korrektem Wert auf
                }
            }, 1000);
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // --- Gamification ---
        correctBtn.addEventListener('click', () => handleAnswer(true));
        incorrectBtn.addEventListener('click', () => handleAnswer(false));

        // NEU: Allgemeine Funktion zur Beantwortung von Karten (f√ºr SRS)
        function handleAnswer(isCorrect) {
            if (flashcards.length === 0 || currentCardIndex >= flashcards.length) return;
            const currentCard = flashcards[currentCardIndex];
            const originalCard = originalFlashcards.find(card => 
                card.question === currentCard.question && card.answer === currentCard.answer);
            
            if (originalCard) {
                originalCard.progress[learningMode] = isCorrect ? 'correct' : 'incorrect'; 

                // NEU: SRS-Logik
                if (learningMode === 'normal') { // SRS nur im Normalmodus anwenden
                    let srs = originalCard.srs;
                    if (isCorrect) {
                        srs.repetitions++;
                        if (srs.repetitions === 1) {
                            srs.interval = 1;
                        } else if (srs.repetitions === 2) {
                            srs.interval = 6;
                        } else {
                            srs.interval = Math.round(srs.interval * srs.easeFactor);
                        }
                        srs.easeFactor = srs.easeFactor + (0.1 - (5 - 3) * (0.08 + (5 - 3) * 0.02)); // Grade 3 for correct
                    } else { // Incorrect
                        srs.repetitions = 0;
                        srs.interval = 1; // Wiederhole am n√§chsten Tag
                        srs.easeFactor = Math.max(1.3, srs.easeFactor - 0.2); // Ease-Factor reduzieren, min 1.3
                    }
                    // dueDate aktualisieren
                    const today = new Date(getTodayIsoDate());
                    const nextDueDate = new Date(today.setDate(today.getDate() + srs.interval));
                    srs.dueDate = nextDueDate.toISOString().split('T')[0];
                }
            }
            showMotivationalMessageBasedOnCount(isCorrect); 
            earnBadgeByCriteria();
            moveToNextCard();
        }


        function showMotivationalMessageBasedOnCount(isCorrect) {
            const processedCount = getProcessedCardsCount(learningMode); 
            if (isCorrect) {
                setMascotAnimationEmoji(MASCOT_HAPPY); 
                if (processedCount > 0 && processedCount % 10 === 0) {
                    const messages = [
                        'Super, weiter so!',
                        'Du rockst das!',
                        'Fantastisch gelernt!',
                        'Mach weiter so, bald hast du es geschafft!',
                        'Beeindruckend!'
                    ];
                    const randomIndex = Math.floor(Math.random() * messages.length);
                    showMotivationalMessage(messages[randomIndex]); 
                }
            } else {
                setMascotAnimationEmoji(MASCOT_THINKING);
                showMotivationalMessage(''); // Leere Nachricht, da nur die Animation wichtig ist
            }
        }

        function showMotivationalMessage(message) { 
            if (message) {
                motivationMessage.textContent = message;
                motivationMessage.style.display = 'block';
                motivationMessage.classList.remove('fadeInOut');
                void motivationMessage.offsetWidth; 
                motivationMessage.classList.add('fadeInOut');
                
                // Timer f√ºr das Ausblenden der Textnachricht
                clearTimeout(motivationMessage.timerId); 
                motivationMessage.timerId = setTimeout(() => {
                    motivationMessage.style.display = 'none';
                }, 1000); 
            } else {
                motivationMessage.style.display = 'none'; // Keine Nachricht, also ausblenden
            }
        }

        function setMascotDisplay(emoji) { 
            mascotEmoji.textContent = emoji;
            // Animationen hier nicht entfernen, da sie beim 'animationend' Listener entfernt werden
        }

        function setMascotAnimationEmoji(emoji) { 
            mascotEmoji.textContent = emoji;
            mascotContainer.classList.remove('correct-animation', 'incorrect-animation'); // Sicherstellen, dass alte Klassen entfernt sind
            void mascotContainer.offsetWidth; // Erzwinge Reflow, um Animation neu zu starten
            mascotContainer.classList.add(emoji === MASCOT_HAPPY ? 'correct-animation' : 'incorrect-animation');
        }

        // --- Abzeichen-Logik ---
        // Statt earnedBadges als Array von IDs, ist es jetzt ein Objekt { id: level }
        function earnBadge(badgeId, level = 1) {
            // Nur verdienen, wenn das Abzeichen noch nicht auf diesem Level oder h√∂her ist
            if (!earnedBadges[badgeId] || earnedBadges[badgeId] < level) {
                earnedBadges[badgeId] = level;
                saveStateToLocalStorage();
                const badgeDef = BADGES.find(b => b.id === badgeId);
                const levelDef = badgeDef.levels.find(l => l.level === level);
                if (levelDef) {
                    showMotivationalMessage(`Neues Abzeichen: "${badgeDef.name}" (Stufe ${level}): "${levelDef.description}" ${levelDef.icon}`);
                }
            }
        }

        function earnBadgeByCriteria() {
            const processedNormal = getProcessedCardsCount('normal');
            const correctlyAnsweredNormal = getCorrectlyAnsweredCount('normal');
            const totalCardsInSet = originalFlashcards.length;

            BADGES.forEach(badgeDef => {
                badgeDef.levels.forEach(levelDef => {
                    let meetsCriteria = false;
                    switch (badgeDef.id) {
                        case 'first_card':
                            meetsCriteria = processedNormal >= levelDef.threshold;
                            break;
                        case 'total_correct':
                            meetsCriteria = correctlyAnsweredNormal >= levelDef.threshold;
                            break;
                        case 'first_set':
                            meetsCriteria = totalCardsInSet > 0 && processedNormal === totalCardsInSet;
                            // Zus√§tzliche Bedingung: Alle Karten im Normalmodus als 'correct' markiert
                            meetsCriteria = meetsCriteria && originalFlashcards.every(card => card.progress.normal === 'correct');
                            break;
                        case 'quiz_master':
                            // Hier m√ºsstest du eine Z√§hlung f√ºr Quiz-Erfolge haben
                            // Beispielhaft: wenn 10 Quizfragen korrekt gel√∂st wurden (angenommen, das ist ein Z√§hler)
                            // const quizCorrectCount = ...;
                            // meetsCriteria = quizCorrectCount >= levelDef.threshold;
                            // Aktuell ohne spezifischen Quiz-Z√§hler, nur als Placeholder
                            break;
                        case 'review_hero':
                             // Wenn alle falsch beantworteten Karten im Normalmodus einmal wiederholt wurden
                             // (isReviewMode endet erfolgreich)
                            break; 
                        case 'memory_pro':
                            // Wird manuell durch das Spiel gesetzt
                            break;
                    }

                    if (meetsCriteria) {
                        // Nur verdienen, wenn das Level h√∂her ist als das aktuell erreichte
                        if (!earnedBadges[badgeDef.id] || earnedBadges[badgeDef.id] < levelDef.level) {
                            earnBadge(badgeDef.id, levelDef.level);
                        }
                    }
                });
            });
        }


        showBadgesBtn.addEventListener('click', displayBadges);
        closeBadgesBtn.addEventListener('click', () => badgeGalleryOverlay.style.display = 'none');

        function displayBadges() {
            badgeGallery.innerHTML = '';
            BADGES.forEach(badgeDef => {
                // Finde das h√∂chste erreichte Level f√ºr dieses Abzeichen
                const currentLevel = earnedBadges[badgeDef.id] || 0;
                let displayLevel = null;
                let nextLevelProgress = null;

                // Finde das h√∂chste Level, das der Nutzer erreicht hat, oder das n√§chste erreichbare
                for (let i = badgeDef.levels.length - 1; i >= 0; i--) {
                    if (currentLevel >= badgeDef.levels[i].level) {
                        displayLevel = badgeDef.levels[i];
                        break;
                    }
                }
                
                // Wenn ein Level erreicht wurde, suche das n√§chste Level, falls vorhanden
                if (displayLevel) {
                    const nextLevelIndex = badgeDef.levels.findIndex(l => l.level === displayLevel.level) + 1;
                    if (nextLevelIndex < badgeDef.levels.length) {
                        const nextLevelDef = badgeDef.levels[nextLevelIndex];
                        // Hier m√ºssten wir den aktuellen Fortschritt zum n√§chsten Schwellenwert berechnen
                        let currentProgressValue = 0;
                        switch (badgeDef.id) {
                            case 'total_correct':
                                currentProgressValue = getCorrectlyAnsweredCount('normal');
                                break;
                            case 'first_card':
                                currentProgressValue = getProcessedCardsCount('normal');
                                break;
                            case 'quiz_master':
                                // ToDo: Quiz-Erfolge z√§hlen
                                break;
                            // ... weitere Logik f√ºr andere Badges
                        }
                        nextLevelProgress = `(${currentProgressValue}/${nextLevelDef.threshold})`;
                    }
                } else {
                    // Wenn noch kein Level erreicht, zeige das erste Level an
                    displayLevel = badgeDef.levels[0];
                    let currentProgressValue = 0;
                    switch (badgeDef.id) {
                        case 'total_correct':
                            currentProgressValue = getCorrectlyAnsweredCount('normal');
                            break;
                        case 'first_card':
                            currentProgressValue = getProcessedCardsCount('normal');
                            break;
                        case 'quiz_master':
                            // ToDo: Quiz-Erfolge z√§hlen
                            break;
                    }
                    nextLevelProgress = `(${currentProgressValue}/${displayLevel.threshold})`;
                }

                const badgeItem = document.createElement('div');
                badgeItem.classList.add('badge-item');
                // Wenn ein Level erreicht wurde (currentLevel > 0)
                if (currentLevel > 0) {
                    badgeItem.classList.add('earned');
                }
                
                badgeItem.innerHTML = `
                    <span class="badge-icon">${displayLevel.icon}</span>
                    <span>${badgeDef.name} ${currentLevel > 0 ? `Lv.${currentLevel}` : ''}</span>
                    <small>${displayLevel.description}</small>
                    ${nextLevelProgress ? `<small>N√§chste Stufe: ${nextLevelProgress}</small>` : ''}
                `;
                badgeGallery.appendChild(badgeItem);
            });
            badgeGalleryOverlay.style.display = 'flex';
        }


        // --- Navigation ---
        nextCardBtn.addEventListener('click', () => {
            moveToNextCard();
        });

        prevCardBtn.addEventListener('click', () => {
            // Im Normalmodus linear zur√ºckgehen
            if (learningMode === 'normal' && !isReviewMode) {
                if (currentCardIndex > 0) {
                    currentCardIndex--;
                    displayCard();
                    updateProgress();
                    updateCardCounter();
                    saveStateToLocalStorage();
                }
            } else {
                // In anderen Modi (Quiz, Game, Review) ist "vorherige Karte" komplex oder nicht sinnvoll.
                // Hier k√∂nnte eine Meldung angezeigt oder der Button deaktiviert werden.
                showMotivationalMessage('Im aktuellen Modus ist die "vorherige Karte" nicht verf√ºgbar.');
            }
        });

        function moveToNextCard() {
            if (learningMode === 'normal' && !isReviewMode) {
                // SRS-Logik: Finde die n√§chste f√§llige Karte
                const today = new Date(getTodayIsoDate());
                let nextCard = flashcards.find(card => 
                    card.progress.normal !== 'correct' && new Date(card.srs.dueDate) <= today
                );

                if (!nextCard) {
                    // Wenn keine f√§lligen Karten mehr da sind, zeige die am l√§ngsten nicht gesehene Karte (oder zuf√§llige unbearbeitete)
                    nextCard = flashcards.find(card => card.progress.normal === 'unanswered');
                    if (!nextCard) {
                        // Wenn alle Karten beantwortet sind, zeige Karten, die noch nicht "richtig" waren, nach SRS-Intervall
                        nextCard = flashcards
                            .filter(card => card.progress.normal !== 'correct')
                            .sort((a, b) => new Date(a.srs.dueDate) - new Date(b.srs.dueDate))[0];
                    }
                }
                
                if (nextCard) {
                    currentCardIndex = flashcards.indexOf(nextCard);
                } else {
                    currentCardIndex = flashcards.length; // Alle Karten bearbeitet
                }

            } else {
                // Bestehende Logik f√ºr Quiz/Game/Review Mode
                currentCardIndex++;
            }
            displayCard();
            updateProgress();
            updateCardCounter();
            saveStateToLocalStorage();
        }

        // --- Lernmodi ---
        normalModeBtn.addEventListener('click', () => setLearningMode('normal'));
        quizModeBtn.addEventListener('click', () => setLearningMode('quiz'));
        startGameBtn.addEventListener('click', () => {
            const games = ['memory'];
            const randomGame = games[Math.floor(Math.random() * games.length)];
            setLearningMode('game', randomGame);
        });

        function setLearningMode(mode, gameType = '') {
            if (isReviewMode) {
                isReviewMode = false;
                normalModeBtn.textContent = 'Normalmodus';
                quizModeBtn.style.display = 'inline-block'; 
                showBadgesBtn.style.display = 'inline-block'; 
                startGameBtn.style.display = 'inline-block'; 
            }

            if ((learningMode === 'normal' && mode === 'quiz') || 
                (learningMode === 'quiz' && mode === 'normal')) {
                flashcards = [...originalFlashcards]; 
                shuffleFlashcards();
                currentCardIndex = 0; 
            }
            if (learningMode === 'game' && (mode === 'normal' || mode === 'quiz')) {
                 flashcards = [...originalFlashcards]; 
                 shuffleFlashcards();
                 currentCardIndex = 0;
            }
            // Beim Wechsel in den Normalmodus (ohne Review), Flashcards nach SRS sortieren
            if (mode === 'normal' && !isReviewMode && originalFlashcards.length > 0) {
                const today = new Date(getTodayIsoDate());
                const dueCards = originalFlashcards.filter(card => new Date(card.srs.dueDate) <= today);
                shuffleArray(dueCards);
                const notDueCards = originalFlashcards.filter(card => new Date(card.srs.dueDate) > today);
                shuffleArray(notDueCards);
                flashcards = [...dueCards, ...notDueCards];
                currentCardIndex = 0;
            }


            learningMode = mode;
            gameMode = gameType; 

            document.querySelectorAll('.mode-selection button').forEach(btn => btn.classList.remove('active'));
            const currentModeBtn = document.getElementById(`${mode}ModeBtn`);
            if (currentModeBtn) {
                currentModeBtn.classList.add('active');
            }

            if (learningMode === 'game') {
                appControls.style.display = 'none'; 
                miniGameOverlay.style.display = 'flex';
                startGame(gameMode);
            } else {
                miniGameOverlay.style.display = 'none';
                appControls.style.display = 'block'; 
                displayCard(); 
                updateProgress(); 
                updateCardCounter(); 
            }
            saveStateToLocalStorage();
        }

        // --- Fortschritt & Wiederholung ---
        function updateProgress() {
            if (originalFlashcards.length === 0) {
                progressBar.style.width = '0%';
                progressText.textContent = '0%';
                cardCounterDisplay.textContent = `Bearbeitete Karten: 0 | Richtig: 0 | Falsch: 0`;
                reviewIncorrectBtn.style.display = 'none';
                return;
            }
            const modeForProgress = isReviewMode ? 'normal' : learningMode; // Review zeigt Normal-Fortschritt
            const processedCount = getProcessedCardsCount(modeForProgress);
            const correctlyAnsweredCount = getCorrectlyAnsweredCount(modeForProgress);
            const incorrectlyAnsweredCount = getIncorrectlyAnsweredCount(modeForProgress);
            const totalCards = originalFlashcards.length;

            const progress = (processedCount / totalCards) * 100;
            progressBar.style.width = `${progress}%`;
            progressText.textContent = `${Math.round(progress)}%`;

            const correctProgress = (correctlyAnsweredCount / totalCards) * 100;
            progressBar.style.backgroundImage = `linear-gradient(to right, var(--correct-light) ${correctProgress}%, var(--primary-light) ${correctProgress}%)`;
            
            if (getIncorrectlyAnsweredCount('normal') > 0 && !isReviewMode && learningMode === 'normal') {
                reviewIncorrectBtn.style.display = 'block';
            } else {
                reviewIncorrectBtn.style.display = 'none';
            }
        }

        function updateCardCounter() {
            const modeForProgress = isReviewMode ? 'normal' : learningMode;
            const processed = getProcessedCardsCount(modeForProgress);
            const correct = getCorrectlyAnsweredCount(modeForProgress);
            const incorrect = getIncorrectlyAnsweredCount(modeForProgress);
            cardCounterDisplay.textContent = `Bearbeitete Karten: ${processed} | Richtig: ${correct} | Falsch: ${incorrect}`;
        }

        reviewIncorrectBtn.addEventListener('click', startReviewMode);
        resetProgressBtn.addEventListener('click', resetProgress);

        function startReviewMode() {
            const reviewCards = originalFlashcards.filter(card => card.progress.normal === 'incorrect');
            if (reviewCards.length === 0) {
                showMotivationalMessage('Keine falsch beantworteten Karten zum Wiederholen im Normalmodus!');
                return;
            }
            isReviewMode = true;
            flashcards = [...reviewCards]; 
            shuffleFlashcards();
            currentCardIndex = 0;
            
            reviewIncorrectBtn.style.display = 'none';
            normalModeBtn.textContent = 'Normalmodus';
            quizModeBtn.style.display = 'none';
            showBadgesBtn.style.display = 'none'; 
            startGameBtn.style.display = 'none'; 
            
            showMotivationalMessage('Wiederholungsmodus gestartet!');
            displayCard();
            updateProgress(); 
            updateCardCounter(); 
            saveStateToLocalStorage();
        }

        function resetProgress() {
            const confirmed = true; 
            if (confirmed) {
                if (currentActiveSetKey && allFlashcardSets[currentActiveSetKey]) {
                    allFlashcardSets[currentActiveSetKey].cards.forEach(card => { // Zugriff auf cards im Set-Objekt
                        card.progress.normal = 'unanswered';
                        card.progress.quiz = 'unanswered';
                        // NEU: SRS-Daten zur√ºcksetzen
                        card.srs = { interval: 0, easeFactor: 2.5, repetitions: 0, dueDate: getTodayIsoDate() };
                    });
                } else { // Fallback, falls currentActiveSetKey nicht gesetzt ist
                    originalFlashcards.forEach(card => {
                        card.progress.normal = 'unanswered';
                        card.progress.quiz = 'unanswered';
                        // NEU: SRS-Daten zur√ºcksetzen
                        card.srs = { interval: 0, easeFactor: 2.5, repetitions: 0, dueDate: getTodayIsoDate() };
                    });
                }
                
                flashcards = [...originalFlashcards]; 
                shuffleFlashcards();
                currentCardIndex = 0;
                isReviewMode = false;
                earnedBadges = {}; // Alle Abzeichen zur√ºcksetzen
                
                normalModeBtn.textContent = 'Normalmodus';
                normalModeBtn.classList.add('active'); 
                quizModeBtn.style.display = 'inline-block';
                showBadgesBtn.style.display = 'inline-block'; 
                startGameBtn.style.display = 'inline-block'; 
                learningMode = 'normal'; 
                document.querySelectorAll('.mode-selection button').forEach(btn => btn.classList.remove('active'));
                document.getElementById(`${learningMode}ModeBtn`).classList.add('active');


                displayCard();
                updateProgress();
                updateCardCounter();
                saveStateToLocalStorage();
                showMotivationalMessage('Fortschritt zur√ºckgesetzt!');
                correctBtn.style.display = 'inline-block';
                incorrectBtn.style.display = 'inline-block';
                nextCardBtn.style.display = 'inline-block';
                prevCardBtn.style.display = 'inline-block';
                reviewIncorrectBtn.style.display = 'none'; 
            }
        }

        // --- LocalStorage ---
        function saveStateToLocalStorage() {
            localStorage.setItem('flashcardAppState', JSON.stringify({
                allFlashcardSets: allFlashcardSets, 
                currentActiveSetKey: currentActiveSetKey, 
                currentCardIndex,
                isReviewMode,
                learningMode,
                darkModeEnabled,
                earnedBadges, 
                userSelectedMascotEmoji, // Speichere den vom Benutzer ausgew√§hlten Maskottchen-Emoji
                questionLang: questionLangSelect.value, 
                answerLang: answerLangSelect.value 
            }));
        }

        function loadStateFromLocalStorage() {
            const savedState = localStorage.getItem('flashcardAppState');
            if (savedState) {
                const state = JSON.parse(savedState);
                
                allFlashcardSets = state.allFlashcardSets || {};
                currentActiveSetKey = state.currentActiveSetKey || null;

                // Migration und Sicherstellung der Datenstruktur
                // Wenn alte 'originalFlashcards' direkt im State sind, migriere sie in ein 'default_set'
                if (state.originalFlashcards && !allFlashcardSets['default_set']) {
                    const migratedCards = state.originalFlashcards.map(card => {
                        // F√ºge progress und srs hinzu, falls sie fehlen
                        if (!card.progress) {
                            card.progress = { normal: card.status || 'unanswered', quiz: 'unanswered' };
                            delete card.status;
                        } else if (!card.progress.quiz) {
                            card.progress.quiz = 'unanswered';
                        }
                        if (!card.srs) { // NEU: SRS-Migration
                             card.srs = { interval: 0, easeFactor: 2.5, repetitions: 0, dueDate: getTodayIsoDate() };
                        }
                        return card;
                    });
                    allFlashcardSets['default_set'] = { cards: migratedCards, rawInfoContent: '' }; // Leerer Rohinhalt f√ºr migrierte Sets
                    currentActiveSetKey = 'default_set';
                    fileNameDisplay.textContent = 'Lerninhalte aus dem letzten Besuch (migriert) geladen.';
                }

                // Sicherstellung der Datenstruktur f√ºr alle geladenen Sets
                for (const setName in allFlashcardSets) {
                    if (allFlashcardSets[setName].cards) { // Pr√ºfe, ob 'cards' Eigenschaft existiert
                        allFlashcardSets[setName].cards.forEach(card => {
                            if (!card.progress) {
                                card.progress = { normal: 'unanswered', quiz: 'unanswered' };
                                if (card.status) { card.status = card.progress.normal; } // Stellt sicher, dass status f√ºr alte Formate richtig gesetzt wird
                            } else if (!card.progress.quiz) {
                                card.progress.quiz = 'unanswered';
                            }
                            if (!card.srs) { // NEU: SRS-Migration f√ºr alle Sets
                                card.srs = { interval: 0, easeFactor: 2.5, repetitions: 0, dueDate: getTodayIsoDate() };
                            }
                        });
                    } else { // Wenn ein altes Set direkt ein Array von Karten war, wandle es um
                        allFlashcardSets[setName] = { cards: allFlashcardSets[setName], rawInfoContent: '' };
                        allFlashcardSets[setName].cards.forEach(card => {
                             if (!card.progress) {
                                card.progress = { normal: 'unanswered', quiz: 'unanswered' };
                                if (card.status) { card.status = card.progress.normal; } // Stellt sicher, dass status f√ºr alte Formate richtig gesetzt wird
                            }
                            if (!card.srs) { 
                                card.srs = { interval: 0, easeFactor: 2.5, repetitions: 0, dueDate: getTodayIsoDate() };
                            }
                        });
                    }
                    // Stelle sicher, dass rawInfoContent existiert
                    if (allFlashcardSets[setName].rawInfoContent === undefined) {
                        allFlashcardSets[setName].rawInfoContent = ''; 
                    }
                }

                currentCardIndex = state.currentCardIndex || 0;
                isReviewMode = state.isReviewMode || false;
                learningMode = state.learningMode || 'normal';
                darkModeEnabled = state.darkModeEnabled !== undefined ? state.darkModeEnabled : true;
                earnedBadges = state.earnedBadges || {}; // Lade als Objekt
                userSelectedMascotEmoji = state.userSelectedMascotEmoji || 'üôÇ'; // Lade Maskottchen Emoji
                
                loadedQuestionLang = state.questionLang || 'de-DE';
                loadedAnswerLang = state.answerLang || 'de-DE';

                document.querySelectorAll('.mode-selection button').forEach(btn => btn.classList.remove('active'));
                const currentModeBtn = document.getElementById(`${learningMode}ModeBtn`);
                if (currentModeBtn) {
                    currentModeBtn.classList.add('active');
                }

                if (currentActiveSetKey && allFlashcardSets[currentActiveSetKey]) {
                    fileNameDisplay.textContent = `Lerninhalte "${currentActiveSetKey}" geladen.`;
                } else if (Object.keys(allFlashcardSets).length > 0) {
                    currentActiveSetKey = Object.keys(allFlashcardSets)[0]; // W√§hle das erste Set, wenn kein aktives Set gespeichert ist
                    fileNameDisplay.textContent = `Lerninhalte "${currentActiveSetKey}" geladen.`;
                } else {
                    fileNameDisplay.textContent = 'Keine Datei geladen. Lade eine Datei hoch.';
                }
            }
        }

        function populateSavedSetsSelect() {
            savedSetsSelect.innerHTML = '';
            let defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = '--- Gespeicherte Inhalte ausw√§hlen ---';
            savedSetsSelect.appendChild(defaultOption);

            const sortedKeys = Object.keys(allFlashcardSets).sort(); 
            sortedKeys.forEach(key => {
                let option = document.createElement('option');
                option.value = key;
                option.textContent = key;
                savedSetsSelect.appendChild(option);
            });

            if (currentActiveSetKey) {
                savedSetsSelect.value = currentActiveSetKey;
            } else {
                savedSetsSelect.value = '';
            }

            savedSetsSelect.disabled = (sortedKeys.length === 0);
        }

        savedSetsSelect.addEventListener('change', (event) => {
            const selectedSetKey = event.target.value;
            if (selectedSetKey && allFlashcardSets[selectedSetKey]) {
                currentActiveSetKey = selectedSetKey;
                originalFlashcards = allFlashcardSets[selectedSetKey].cards; // Lade Karten aus dem Set-Objekt
                fileNameDisplay.textContent = `Lerninhalte "${selectedSetKey}" geladen.`;
                flashcards = [...originalFlashcards];
                // Beim Set-Wechsel immer in den Normalmodus und SRS-Sortierung anwenden
                shuffleFlashcards(); // Mische zuerst, um eine zuf√§llige Reihenfolge innerhalb der SRS-Gruppen zu gew√§hrleisten
                if (learningMode === 'normal' && !isReviewMode) {
                    const today = new Date(getTodayIsoDate());
                    const dueCards = flashcards.filter(card => new Date(card.srs.dueDate) <= today);
                    shuffleArray(dueCards);
                    const notDueCards = flashcards.filter(card => new Date(card.srs.dueDate) > today);
                    shuffleArray(notDueCards);
                    flashcards = [...dueCards, ...notDueCards];
                }
                currentCardIndex = 0;
                isReviewMode = false;
                setLearningMode('normal'); 
                updateProgress();
                updateCardCounter();
                saveStateToLocalStorage();
                appControls.style.display = 'block'; 
            } else if (selectedSetKey === '') {
                originalFlashcards = [];
                flashcards = [];
                currentActiveSetKey = null;
                currentCardIndex = 0;
                isReviewMode = false;
                appControls.style.display = 'none';
                fileNameDisplay.textContent = 'Keine Datei geladen. Lade eine Datei hoch.';
                updateProgress();
                updateCardCounter();
                saveStateToLocalStorage();
            }
        });


        // --- Dark Mode ---
        darkModeToggle.addEventListener('click', toggleDarkMode);

        function toggleDarkMode() {
            darkModeEnabled = !darkModeEnabled;
            updateDarkModeUI();
            saveStateToLocalStorage();
        }

        function updateDarkModeUI() {
            if (darkModeEnabled) {
                document.documentElement.classList.add('dark-mode');
                darkModeToggle.textContent = '‚òÄÔ∏è';
            } else {
                document.documentElement.classList.remove('dark-mode');
                darkModeToggle.textContent = 'üí°';
            }
        }

        // --- Settings Overlay Logic ---
        settingsBtn.addEventListener('click', () => {
            settingsOverlay.style.display = 'flex';
        });

        closeSettingsBtn.addEventListener('click', () => {
            settingsOverlay.style.display = 'none';
        });

        // --- Maskottchen Anpassungs-Overlay ---
        mascotContainer.addEventListener('click', () => {
            populateMascotOptions();
            mascotCustomizationOverlay.style.display = 'flex';
        });

        closeMascotCustomizationBtn.addEventListener('click', () => {
            mascotCustomizationOverlay.style.display = 'none';
        });

        function populateMascotOptions() {
            mascotOptionsContainer.innerHTML = ''; // Vorhandene Optionen entfernen

            MASCOT_EMOJIS.forEach(option => {
                const optionItem = document.createElement('div');
                optionItem.classList.add('mascot-option-item');
                optionItem.innerHTML = `${option.emoji}<small>${option.name}</small>`;
                
                let isLocked = false;
                if (option.unlockCriteria.type === 'always') {
                    // Immer freigeschaltet
                } else if (option.unlockCriteria.type === 'total_correct') {
                    const totalCorrect = getCorrectlyAnsweredCount('normal');
                    if (totalCorrect < option.unlockCriteria.threshold) {
                        isLocked = true;
                        optionItem.innerHTML += `<small>${totalCorrect}/${option.unlockCriteria.threshold} Richtig</small>`;
                    }
                } else if (option.unlockCriteria.type === 'quiz_master') {
                    // F√ºr quiz_master: Pr√ºfe ob Abzeichen verdient wurde
                    if (!earnedBadges['quiz_master'] || earnedBadges['quiz_master'] < option.unlockCriteria.threshold) {
                        isLocked = true;
                        optionItem.innerHTML += `<small>Ben√∂tigt Quiz-Meister</small>`;
                    }
                } else if (option.unlockCriteria.type === 'first_set') {
                    if (!earnedBadges['first_set'] || earnedBadges['first_set'] < option.unlockCriteria.threshold) {
                        isLocked = true;
                        optionItem.innerHTML += `<small>Ben√∂tigt Satz-Bezwinger</small>`;
                    }
                } else if (option.unlockCriteria.type === 'memory_pro') {
                     if (!earnedBadges['memory_pro'] || earnedBadges['memory_pro'] < option.unlockCriteria.threshold) {
                        isLocked = true;
                        optionItem.innerHTML += `<small>Ben√∂tigt Memory-Meister</small>`;
                    }
                }
                // F√ºge hier weitere unlockCriteria-Typen hinzu

                if (isLocked) {
                    optionItem.classList.add('locked');
                } else {
                    optionItem.addEventListener('click', () => {
                        userSelectedMascotEmoji = option.emoji; // Aktualisiere den vom Benutzer ausgew√§hlten Emoji
                        setMascotDisplay(userSelectedMascotEmoji); // Aktualisiere die Anzeige
                        // Optional: Visuelles Feedback im Men√º
                        mascotOptionsContainer.querySelectorAll('.mascot-option-item').forEach(item => {
                            item.classList.remove('selected');
                        });
                        optionItem.classList.add('selected');
                        saveStateToLocalStorage(); // Speichere die Auswahl
                    });
                }

                if (option.emoji === userSelectedMascotEmoji) { // √úberpr√ºfe userSelectedMascotEmoji f√ºr die Auswahlmarkierung
                    optionItem.classList.add('selected');
                }

                mascotOptionsContainer.appendChild(optionItem);
            });
        }


        // --- Mini-Spiel Logik ---
        closeGameBtn.addEventListener('click', () => {
            miniGameOverlay.style.display = 'none';
            setLearningMode('normal'); 
            gameArea.innerHTML = ''; 
        });
        nextGameBtn.addEventListener('click', () => {
            const games = ['memory'];
            const randomGame = games[Math.floor(Math.random() * games.length)];
            setLearningMode('game', randomGame);
        });

        function startGame(type) {
            if (originalFlashcards.length < 2) {
                showMotivationalMessage('Lade mindestens 2 Karten hoch, um ein Mini-Spiel zu starten!');
                miniGameOverlay.style.display = 'none';
                setLearningMode('normal');
                return;
            }
            // Memory ben√∂tigt mindestens 2 Paare, also 4 unique Antworten
            if (type === 'memory' && originalFlashcards.filter(card => card.answer.trim() !== '').length < 4) {
                showMotivationalMessage('Du brauchst mindestens 4 einzigartige Antworten f√ºr das Memory-Spiel (2 Paare)!');
                miniGameOverlay.style.display = 'none';
                setLearningMode('normal');
                return;
            }

            gameArea.innerHTML = ''; 
            nextGameBtn.style.display = 'none'; 

            if (type === 'memory') {
                gameTitle.textContent = 'Paare finden (Memory)';
                initMemoryGame();
            } 
        }
        
        // Memory Game
        function initMemoryGame() {
            const uniqueCards = [];
            const seenAnswers = new Set();
            for (const card of originalFlashcards) {
                // F√ºge nur Karten hinzu, die eine nicht-leere Antwort haben und deren Antwort noch nicht verwendet wurde
                if (card.answer.trim() !== '' && !seenAnswers.has(card.answer.trim().toLowerCase())) {
                    uniqueCards.push(card);
                    seenAnswers.add(card.answer.trim().toLowerCase());
                }
            }

            shuffleArray(uniqueCards);
            // W√§hle maximal 4 unique Karten f√ºr das Spiel (ergibt 4 Paare = 8 Karten), mindestens aber 2 Paare
            currentGameCardSet = uniqueCards.slice(0, Math.min(4, Math.floor(uniqueCards.length / 2) * 2)); // Sicherstellen, dass es immer eine gerade Anzahl f√ºr Paare ist
            
            if (currentGameCardSet.length < 2) { // Mindestens 2 unique Karten (f√ºr ein Paar)
                showMotivationalMessage('Nicht genug unterschiedliche Karten f√ºr Memory (mind. 2 Paare ben√∂tigt)!');
                miniGameOverlay.style.display = 'none';
                setLearningMode('normal');
                return;
            }

            memoryCards = [];
            currentGameCardSet.forEach((card, index) => {
                memoryCards.push({ id: `card-${index}-q`, type: 'question', content: card.question, pairId: index, flipped: false, matched: false });
                memoryCards.push({ id: `card-${index}-a`, type: 'answer', content: card.answer, pairId: index, flipped: false, matched: false });
            });
            shuffleArray(memoryCards);

            matchedMemoryPairs = 0;
            flippedMemoryCards = [];
            isMemoryChecking = false; 

            renderMemoryBoard();
        }

        function renderMemoryBoard() {
            gameArea.innerHTML = '<div id="memoryBoard"></div>';
            const board = document.getElementById('memoryBoard');
            board.innerHTML = ''; 

            // Bestimme die Spaltenanzahl basierend auf der Anzahl der Karten
            let columns = 4; // Standard f√ºr 8 Karten
            if (memoryCards.length <= 6) { // F√ºr 2 oder 3 Paare (4 oder 6 Karten)
                columns = 3;
            } else if (memoryCards.length <= 4) { // F√ºr 2 Paare (4 Karten)
                columns = 2;
            }
            board.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;

            memoryCards.forEach(card => {
                const cardElement = document.createElement('div');
                cardElement.classList.add('memory-card');
                cardElement.id = card.id;
                
                // Eine Karte ist "geflippt", wenn sie entweder aktuell aufgedeckt ist ODER wenn sie gematcht wurde
                if (card.flipped || card.matched) { 
                    cardElement.classList.add('flipped');
                }
                if (card.matched) {
                    cardElement.classList.add('matched');
                }

                // Verwende die neuen Face-Klassen
                cardElement.innerHTML = `
                    <div class="memory-card-face memory-card-front-face">?</div>
                    <div class="memory-card-face memory-card-back-face">${marked.parse(card.content)}</div>
                `;
                if (!card.matched) { // Nur klickbar machen, wenn nicht gematcht
                    const clickHandler = (e) => flipMemoryCard(card.id);
                    cardElement.removeEventListener('click', clickHandler); 
                    cardElement.addEventListener('click', clickHandler); 
                } else {
                    const clickHandler = (e) => flipMemoryCard(card.id); 
                    cardElement.removeEventListener('click', clickHandler); 
                }
                board.appendChild(cardElement);
            });
        }

        function flipMemoryCard(cardId) {
            if (isMemoryChecking) return; 

            const cardElement = document.getElementById(cardId);
            const card = memoryCards.find(c => c.id === cardId);

            if (!card || card.flipped || card.matched) {
                return; 
            }

            card.flipped = true;
            cardElement.classList.add('flipped');
            flippedMemoryCards.push(card);

            if (flippedMemoryCards.length === 2) {
                isMemoryChecking = true; 
                checkForMatch(); 
            }
        }

        function checkForMatch() {
            const [card1, card2] = flippedMemoryCards;

            if (card1.pairId === card2.pairId) {
                card1.matched = true;
                card2.matched = true;
                
                document.getElementById(card1.id).classList.add('flipped', 'matched');
                document.getElementById(card2.id).classList.add('flipped', 'matched');
                
                matchedMemoryPairs++;
                showMotivationalMessage('Paar gefunden!');
                
                flippedMemoryCards = []; 
                isMemoryChecking = false; 

                if (matchedMemoryPairs * 2 === memoryCards.length) { 
                    showMotivationalMessage('Alle Paare gefunden! Super!'); 
                    earnBadge('memory_pro', 1); // Verdient das Memory-Pro Abzeichen
                    nextGameBtn.style.display = 'block';
                }
                renderMemoryBoard(); 

            } else {
                showMotivationalMessage('Kein Paar. Versuch es nochmal!');
                setTimeout(() => {
                    document.getElementById(card1.id).classList.remove('flipped');
                    document.getElementById(card2.id).classList.remove('flipped');
                    card1.flipped = false; 
                    card2.flipped = false;
                    flippedMemoryCards = []; 
                    isMemoryChecking = false; 
                    renderMemoryBoard(); 
                }, 2000); 
            }
        }

        // --- NEU: Info Overlay Logic ---
        showInfoBtn.addEventListener('click', () => {
            if (currentActiveSetKey && allFlashcardSets[currentActiveSetKey]) {
                const set = allFlashcardSets[currentActiveSetKey];
                if (set.rawInfoContent && set.rawInfoContent.length > 0) {
                    infoContent.innerHTML = marked.parse(set.rawInfoContent);
                } else {
                    infoContent.innerHTML = '<p>F√ºr diese Lerneinheit gibt es keinen spezifischen Info-Bereich vor dem "!flashcards" Trennzeichen.</p><p>Alle Inhalte wurden als Flashcards behandelt.</p>';
                }
            } else {
                infoContent.innerHTML = '<p>Bitte lade zuerst eine Textdatei hoch.</p>';
            }
            infoOverlay.style.display = 'flex';
        });

        closeInfoBtn.addEventListener('click', () => {
            infoOverlay.style.display = 'none';
            speakSelectedTextBtn.style.display = 'none'; // Verstecke den Button, wenn das Overlay geschlossen wird
        });

    </script>
</body>
</html>
